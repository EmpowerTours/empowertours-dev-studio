const axios = require('axios');
const { Octokit } = require('@octokit/rest');
require('dotenv').config();

class GitHubService {
  constructor() {
    // GitHub App credentials
    this.clientId = process.env.GITHUB_APP_CLIENT_ID;
    this.clientSecret = process.env.GITHUB_APP_CLIENT_SECRET;

    if (!this.clientId || !this.clientSecret) {
      console.warn('âš ï¸  GitHub integration not configured');
      this.enabled = false;
      return;
    }

    this.enabled = true;
    console.log('âœ… GitHub Service initialized');
  }

  /**
   * Exchange OAuth code for access token
   */
  async getAccessToken(code) {
    try {
      const response = await axios.post(
        'https://github.com/login/oauth/access_token',
        {
          client_id: this.clientId,
          client_secret: this.clientSecret,
          code
        },
        {
          headers: {
            Accept: 'application/json'
          }
        }
      );

      return response.data.access_token;
    } catch (error) {
      console.error('Failed to get GitHub access token:', error);
      throw new Error('GitHub authentication failed');
    }
  }

  /**
   * Get authenticated user info
   */
  async getUserInfo(accessToken) {
    try {
      const octokit = new Octokit({ auth: accessToken });
      const { data } = await octokit.users.getAuthenticated();

      return {
        username: data.login,
        name: data.name,
        email: data.email,
        avatarUrl: data.avatar_url
      };
    } catch (error) {
      console.error('Failed to get GitHub user info:', error);
      throw new Error('Failed to fetch GitHub user');
    }
  }

  /**
   * Create repository for user
   */
  async createRepository(accessToken, repoName, description, isPrivate = false) {
    try {
      const octokit = new Octokit({ auth: accessToken });

      // Create repo
      const { data: repo } = await octokit.repos.createForAuthenticatedUser({
        name: repoName,
        description: description || 'Generated by EmpowerTours Dev Studio',
        private: isPrivate,
        auto_init: false // We'll push initial commit
      });

      console.log('âœ… Created GitHub repo:', repo.full_name);

      return {
        name: repo.name,
        fullName: repo.full_name,
        url: repo.html_url,
        cloneUrl: repo.clone_url,
        sshUrl: repo.ssh_url
      };
    } catch (error) {
      if (error.status === 422) {
        throw new Error('Repository name already exists');
      }
      console.error('Failed to create repository:', error);
      throw new Error('Failed to create GitHub repository');
    }
  }

  /**
   * Push generated code to repository
   */
  async pushCodeToRepo(accessToken, owner, repoName, generatedCode) {
    try {
      const octokit = new Octokit({ auth: accessToken });

      // Get default branch (usually 'main' or 'master')
      const { data: repo } = await octokit.repos.get({
        owner,
        repo: repoName
      });

      let branch = repo.default_branch || 'main';

      // Create initial commit with all files
      const files = this.prepareFiles(generatedCode);

      // Create blobs for each file
      const blobs = await Promise.all(
        files.map(async (file) => {
          const { data: blob } = await octokit.git.createBlob({
            owner,
            repo: repoName,
            content: Buffer.from(file.content).toString('base64'),
            encoding: 'base64'
          });
          return { path: file.path, sha: blob.sha, mode: '100644', type: 'blob' };
        })
      );

      // Create tree
      const { data: tree } = await octokit.git.createTree({
        owner,
        repo: repoName,
        tree: blobs
      });

      // Create commit
      const { data: commit } = await octokit.git.createCommit({
        owner,
        repo: repoName,
        message: 'ðŸš€ Initial commit - Generated by EmpowerTours Dev Studio\n\nGenerated with AI-powered dApp builder on Monad blockchain.',
        tree: tree.sha
      });

      // Update reference (create branch if doesn't exist)
      try {
        await octokit.git.updateRef({
          owner,
          repo: repoName,
          ref: `heads/${branch}`,
          sha: commit.sha
        });
      } catch (error) {
        // Branch might not exist, create it
        await octokit.git.createRef({
          owner,
          repo: repoName,
          ref: `refs/heads/${branch}`,
          sha: commit.sha
        });
      }

      console.log('âœ… Pushed code to GitHub:', `${owner}/${repoName}`);

      return {
        commitSha: commit.sha,
        commitUrl: `https://github.com/${owner}/${repoName}/commit/${commit.sha}`,
        repoUrl: `https://github.com/${owner}/${repoName}`
      };
    } catch (error) {
      console.error('Failed to push code to GitHub:', error);
      throw new Error('Failed to push code to repository');
    }
  }

  /**
   * Prepare files from generated code
   */
  prepareFiles(generatedCode) {
    const files = [];

    // Contracts
    if (generatedCode.contracts) {
      Object.entries(generatedCode.contracts).forEach(([filename, content]) => {
        files.push({
          path: `contracts/${filename}`,
          content
        });
      });
    }

    // Deploy scripts
    if (generatedCode.deploy) {
      Object.entries(generatedCode.deploy).forEach(([filename, content]) => {
        files.push({
          path: `deploy/${filename}`,
          content
        });
      });
    }

    // Tests
    if (generatedCode.test) {
      Object.entries(generatedCode.test).forEach(([filename, content]) => {
        files.push({
          path: `test/${filename}`,
          content
        });
      });
    }

    // Frontend
    if (generatedCode.frontend) {
      Object.entries(generatedCode.frontend).forEach(([filename, content]) => {
        files.push({
          path: `frontend/src/${filename}`,
          content
        });
      });
    }

    // README
    if (generatedCode.readme) {
      files.push({
        path: 'README.md',
        content: generatedCode.readme
      });
    }

    // Add package.json files
    files.push(
      {
        path: 'package.json',
        content: JSON.stringify({
          name: 'generated-dapp',
          version: '1.0.0',
          description: 'Generated by EmpowerTours Dev Studio',
          scripts: {
            compile: 'hardhat compile',
            test: 'hardhat test',
            deploy: 'hardhat deploy'
          }
        }, null, 2)
      },
      {
        path: 'hardhat.config.js',
        content: `require("@nomicfoundation/hardhat-toolbox");
require("hardhat-deploy");
require("dotenv").config();

module.exports = {
  solidity: "0.8.20",
  networks: {
    monadTestnet: {
      url: process.env.MONAD_TESTNET_RPC || "https://testnet-rpc.monad.xyz",
      chainId: 41454,
      accounts: process.env.DEPLOYER_PRIVATE_KEY ? [process.env.DEPLOYER_PRIVATE_KEY] : [],
    }
  }
};`
      },
      {
        path: '.gitignore',
        content: `node_modules/
.env
cache/
artifacts/
deployments/
typechain-types/`
      }
    );

    return files;
  }

  /**
   * Create repository and push code (all in one)
   */
  async createAndPushRepo(accessToken, repoName, description, generatedCode, isPrivate = false) {
    try {
      // Get user info
      const userInfo = await this.getUserInfo(accessToken);

      // Create repo
      const repo = await this.createRepository(accessToken, repoName, description, isPrivate);

      // Push code
      const result = await this.pushCodeToRepo(accessToken, userInfo.username, repoName, generatedCode);

      return {
        success: true,
        repo,
        commit: result,
        user: userInfo
      };
    } catch (error) {
      console.error('Failed to create and push repo:', error);
      throw error;
    }
  }
}

// Singleton instance
let githubService = null;

module.exports = {
  getGitHubService: () => {
    if (!githubService) {
      githubService = new GitHubService();
    }
    return githubService;
  },
  GitHubService
};
