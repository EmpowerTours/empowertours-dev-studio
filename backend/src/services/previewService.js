const esbuild = require('esbuild');
const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');

class PreviewService {
  constructor() {
    this.previewsDir = path.join(__dirname, '../../previews');
    this.previews = new Map(); // Store preview metadata
    this.ensurePreviewsDir();
    this.startCleanupTimer();

    console.log('‚úÖ Preview Service initialized');
  }

  async ensurePreviewsDir() {
    try {
      await fs.mkdir(this.previewsDir, { recursive: true });
    } catch (error) {
      console.error('Failed to create previews directory:', error);
    }
  }

  /**
   * Generate unique preview ID
   */
  generatePreviewId() {
    return crypto.randomBytes(8).toString('hex');
  }

  /**
   * Build React app for preview
   */
  async buildPreview(generatedCode, metadata) {
    const previewId = this.generatePreviewId();
    const previewDir = path.join(this.previewsDir, previewId);

    try {
      console.log('üî® Building preview:', previewId);

      // Create preview directory
      await fs.mkdir(previewDir, { recursive: true });

      // Prepare files
      const entryFile = await this.prepareEntryFile(previewDir, generatedCode, metadata);

      // Build with esbuild
      const result = await esbuild.build({
        entryPoints: [entryFile],
        bundle: true,
        minify: true,
        format: 'iife',
        platform: 'browser',
        target: ['es2020'],
        outfile: path.join(previewDir, 'bundle.js'),
        loader: {
          '.js': 'jsx',
          '.jsx': 'jsx',
          '.css': 'css'
        },
        define: {
          'process.env.NODE_ENV': '"production"',
          'process.env.REACT_APP_CONTRACT_ADDRESS': `"${metadata.contractAddress || ''}"`,
          'process.env.REACT_APP_NETWORK': '"monadTestnet"'
        },
        external: [], // Bundle everything
        logLevel: 'warning'
      });

      console.log('‚úÖ Preview built:', previewId);

      // Create HTML file
      await this.createHtmlFile(previewDir, metadata);

      // Store preview metadata
      this.previews.set(previewId, {
        id: previewId,
        metadata,
        createdAt: Date.now(),
        expiresAt: Date.now() + (24 * 60 * 60 * 1000) // 24 hours
      });

      return {
        success: true,
        previewId,
        url: `/preview/${previewId}`,
        expiresAt: this.previews.get(previewId).expiresAt
      };

    } catch (error) {
      console.error('‚ùå Preview build failed:', error);

      // Cleanup on error
      try {
        await fs.rm(previewDir, { recursive: true, force: true });
      } catch {}

      throw new Error('Failed to build preview: ' + error.message);
    }
  }

  /**
   * Prepare entry file for React app
   */
  async prepareEntryFile(previewDir, generatedCode, metadata) {
    const srcDir = path.join(previewDir, 'src');
    await fs.mkdir(srcDir, { recursive: true });

    // Write frontend files
    if (generatedCode.frontend) {
      for (const [filename, content] of Object.entries(generatedCode.frontend)) {
        const filepath = path.join(srcDir, filename);
        await fs.writeFile(filepath, content);
      }
    }

    // Create main entry file
    const entryContent = `
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';

const root = createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
`;

    const entryFile = path.join(srcDir, 'index.js');
    await fs.writeFile(entryFile, entryContent);

    return entryFile;
  }

  /**
   * Create HTML file for preview
   */
  async createHtmlFile(previewDir, metadata) {
    const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${metadata.title || 'Generated dApp'} - Preview</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
        'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
        sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .preview-banner {
      background: #ff6b35;
      color: white;
      padding: 8px 16px;
      text-align: center;
      font-size: 14px;
      font-weight: 500;
    }
    #root {
      min-height: calc(100vh - 40px);
    }
  </style>
</head>
<body>
  <div class="preview-banner">
    üîç Preview Mode - Generated by EmpowerTours Dev Studio
  </div>
  <div id="root"></div>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/ethers@6/dist/ethers.umd.min.js"></script>
  <script src="/preview-bundle.js"></script>
</body>
</html>`;

    await fs.writeFile(path.join(previewDir, 'index.html'), html);
  }

  /**
   * Get preview by ID
   */
  async getPreview(previewId) {
    const preview = this.previews.get(previewId);

    if (!preview) {
      throw new Error('Preview not found');
    }

    // Check if expired
    if (Date.now() > preview.expiresAt) {
      await this.deletePreview(previewId);
      throw new Error('Preview expired');
    }

    const previewDir = path.join(this.previewsDir, previewId);

    return {
      id: previewId,
      metadata: preview.metadata,
      htmlPath: path.join(previewDir, 'index.html'),
      bundlePath: path.join(previewDir, 'bundle.js'),
      createdAt: preview.createdAt,
      expiresAt: preview.expiresAt
    };
  }

  /**
   * Delete preview
   */
  async deletePreview(previewId) {
    const previewDir = path.join(this.previewsDir, previewId);

    try {
      await fs.rm(previewDir, { recursive: true, force: true });
      this.previews.delete(previewId);
      console.log('üóëÔ∏è  Deleted preview:', previewId);
    } catch (error) {
      console.error('Failed to delete preview:', error);
    }
  }

  /**
   * Cleanup expired previews
   */
  async cleanupExpired() {
    const now = Date.now();
    const expired = [];

    for (const [id, preview] of this.previews.entries()) {
      if (now > preview.expiresAt) {
        expired.push(id);
      }
    }

    for (const id of expired) {
      await this.deletePreview(id);
    }

    if (expired.length > 0) {
      console.log(`üßπ Cleaned up ${expired.length} expired previews`);
    }
  }

  /**
   * Start cleanup timer (runs every hour)
   */
  startCleanupTimer() {
    setInterval(() => {
      this.cleanupExpired();
    }, 60 * 60 * 1000); // Every hour
  }

  /**
   * Get all active previews (for admin/debugging)
   */
  getActivePreviews() {
    const active = [];
    const now = Date.now();

    for (const [id, preview] of this.previews.entries()) {
      if (now <= preview.expiresAt) {
        active.push({
          id,
          title: preview.metadata.title,
          createdAt: new Date(preview.createdAt).toISOString(),
          expiresAt: new Date(preview.expiresAt).toISOString()
        });
      }
    }

    return active;
  }
}

// Singleton instance
let previewService = null;

module.exports = {
  getPreviewService: () => {
    if (!previewService) {
      previewService = new PreviewService();
    }
    return previewService;
  },
  PreviewService
};
